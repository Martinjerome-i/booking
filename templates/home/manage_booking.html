{% extends "layouts/base.html" %}

{% block title %} Manage Stall {% endblock %} 

<!-- Specific Page CSS goes HERE  -->
{% block stylesheets %}
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
    }
    .container {
        max-width: 1650px;
        margin: 0 auto;
        padding-left: 20px;
        padding-right: 20px;
    }
    .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        border-bottom: 1px solid #ddd;
        padding-bottom: 10px;
    }
    .header h1 {
        margin: 0;
    }
    .btn {
        background-color: #4CAF50;
        border: none;
        color: white;
        padding: 10px 20px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
        cursor: pointer;
        border-radius: 4px;
        margin-right: 5px;
    }
    .btn-primary {
        background-color: #2196F3;
    }
    .btn-danger {
        background-color: #F44336;
    }
    .btn-warning {
        background-color: #FF9800;
    }
    .btn-disabled {
        background-color: #cccccc;
        cursor: not-allowed;
    }
    .hall-display {
        border: 1px solid #ddd;
        overflow: auto;
        margin-bottom: 20px;
        position: relative;
    }
    .stall {
        position: absolute;
        border: 1px solid #ffffff;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
        transition: all 0.3s ease;
    }
    .stall:hover {
        filter: brightness(1.1);
        transform: scale(1.02);
        z-index: 10;
    }
    .stall.available {
        background-color: #451a32;
        border: 1px solid #ffffff;
        cursor: pointer;
    }
    .stall.booked {
        background-color: #868585;
        border: 1px solid #FFFFFF;
        cursor: not-allowed;
        opacity: 0.8;
    }
    .stall.blocked {
        background-color: #aedeed;
        border: 1px solid #ffffff;
        cursor: pointer;
    }
    .stall.selected {
        background-color: #fcc41a;
        border: 1px solid #ffffff;
    }
    .stall-info {
        background-color: #f9f9f9;
        border: 1px solid #ddd;
        padding: 20px;
        border-radius: 5px;
        display: none;
        margin-bottom: 20px;
    }
    .stall-info h3 {
        margin-top: 0;
    }
    .legend {
        display: flex;
        gap: 20px;
        margin-bottom: 20px;
        flex-wrap: wrap;
    }
    .legend-item {
        display: flex;
        align-items: center;
    }
    .legend-color {
        width: 20px;
        height: 20px;
        margin-right: 5px;
        border: 1px solid #333;
    }
    .loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(255,255,255,0.8);
        padding: 20px;
        border-radius: 5px;
        z-index: 100;
    }
    .selected-stalls-list {
        margin-top: 10px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
    }
    .selected-stall-item {
        background-color: #e3f2fd;
        padding: 5px 10px;
        border-radius: 4px;
        display: flex;
        align-items: center;
    }
    .combo-stall-item {
        background-color: #f3e5f5;
        border-left: 3px solid #9C27B0;
    }
    .remove-stall {
        color: #F44336;
        cursor: pointer;
        margin-left: 5px;
        font-weight: bold;
    }
    .selection-info {
        margin-top: 15px;
        font-weight: bold;
    }
    .action-buttons {
        display: flex;
        gap: 10px;
        margin-top: 15px;
    }
    .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
        z-index: 1000;
        justify-content: center;
        align-items: center;
    }
    .modal-content {
        background-color: white;
        padding: 20px;
        border-radius: 5px;
        width: 400px;
        max-width: 90%;
    }
    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
    }
    .modal-header h3 {
        margin: 0;
    }
    .close-modal {
        cursor: pointer;
        font-size: 24px;
        font-weight: bold;
    }
    .form-group {
        margin-bottom: 15px;
    }
    .form-group label {
        display: block;
        font-weight: bold;
        margin-bottom: 5px;
    }
    .form-group input,
    .form-group textarea {
        width: 100%;
        padding: 8px;
        box-sizing: border-box;
        border: 1px solid #ddd;
        border-radius: 4px;
    }
    /* Confirmation modal styles */
    .confirmation-modal {
        text-align: center;
    }
    .confirmation-details {
        margin: 20px 0;
        text-align: left;
        padding: 15px;
        background-color: #f5f5f5;
        border-radius: 5px;
    }
    .confirmation-actions {
        margin-top: 20px;
    }
    .discount-info {
        margin-top: 10px;
        font-style: italic;
        color: #666;
    }
</style>
{% endblock stylesheets %}

{% block content %}

<div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center py-4">
    <div class="d-block mb-4 mb-md-0">
        <nav aria-label="breadcrumb" class="d-none d-md-inline-block">
            <ol class="breadcrumb breadcrumb-dark breadcrumb-transparent">
                <li class="breadcrumb-item">
                    <a href="/">
                        <svg class="icon icon-xxs" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"></path></svg>
                    </a>
                </li>
                <li class="breadcrumb-item"><a href="/">Admin</a></li>
                <li class="breadcrumb-item active" aria-current="page">Manage Stalls</li>
            </ol>
        </nav>
        <h2 class="h4">Stall Management</h2>
        <p class="mb-0">Manage all exhibition stall bookings from this dashboard</p>
    </div>
</div>

<div class="container">
    <div class="header">
        <h1>{{ hall.name }}</h1>
    </div>

    <div class="hall-info">
        <p>Size: {{ hall.length }}m x {{ hall.breadth }}m ({{ hall.total_area }}m²)</p>
    </div>

    <!-- Hall View Section -->
    <div id="hall-view-container">
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background-color: #451a32;"></div>
                <span>Available</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #868585;"></div>
                <span>Booked</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #aedeed;"></div>
                <span>Blocked</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #fcc41a;"></div>
                <span>Selected</span>
            </div>
        </div>

        <!-- Selected stall information -->
        <div id="stall-info" class="stall-info">
            <h3>Selected Stalls</h3>
            <div id="selected-stalls-count" class="selection-info">0 stalls selected</div>
            <div id="selected-stalls-list" class="selected-stalls-list">
                <!-- Selected stalls will be listed here -->
            </div>
            <div id="total-price" class="selection-info" style="margin-top: 15px;">Total: ₹0.00</div>
            <div class="discount-info" id="discount-info">
                <!-- Discount information will be displayed here -->
            </div>
            <div class="action-buttons">
                <button id="block-stalls-btn" class="btn btn-warning">Block Stalls</button>
                <button id="unblock-stalls-btn" class="btn btn-primary">Unblock Stalls</button>
                <button id="book-stalls-btn" class="btn">Book for Customer</button>
            </div>
        </div>

        <div class="hall-display" id="hall-display"
            style="width: 100%; height: 600px;"
            data-hall-id="{{ hall.id }}"
            data-length="{{ hall.length }}"
            data-breadth="{{ hall.breadth }}">
            <div id="loading" class="loading">Loading stalls...</div>
            <!-- Stalls will be drawn here using JavaScript -->
        </div>
    </div>
</div>

<!-- Booking Modal -->
<div id="booking-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>Book Stalls for Customer</h3>
            <span class="close-modal" id="close-booking-modal">&times;</span>
        </div>
        <form id="booking-form">
            <div class="form-group">
                <label for="customer_name">Customer Name *</label>
                <input type="text" id="customer_name" name="customer_name" required>
            </div>
            <div class="form-group">
                <label for="customer_email">Customer Email *</label>
                <input type="email" id="customer_email" name="customer_email" required>
            </div>
            <div class="form-group">
                <label for="customer_phone">Customer Phone *</label>
                <input type="text" id="customer_phone" name="customer_phone" required>
            </div>
            <div class="form-group">
                <label for="company_name">Company Name</label>
                <input type="text" id="company_name" name="company_name">
            </div>
            <div class="form-group">
                <label for="notes">Notes</label>
                <textarea id="notes" name="notes" rows="3"></textarea>
            </div>
            <button type="submit" class="btn">Complete Booking</button>
        </form>
    </div>
</div>

<!-- Booking Confirmation Modal -->
<div id="confirmation-modal" class="modal">
    <div class="modal-content confirmation-modal">
        <div class="modal-header">
            <h3>Booking Confirmed!</h3>
            <span class="close-modal" id="close-confirmation-modal">&times;</span>
        </div>
        <div>
            <p>The stalls have been successfully booked.</p>
            <div class="confirmation-details">
                <p><strong>Booking Reference:</strong> <span id="confirmation-reference"></span></p>
                <p><strong>Customer:</strong> <span id="confirmation-customer"></span></p>
                <p><strong>Total Amount:</strong> ₹<span id="confirmation-amount"></span></p>
                <p><strong>Stalls Booked:</strong> <span id="confirmation-stalls"></span></p>
            </div>
        </div>
        <div class="confirmation-actions">
            <button id="close-confirmation-btn" class="btn btn-primary">Close</button>
        </div>
    </div>
</div>

{% endblock content %}

<!-- Specific Page JS goes HERE  -->
{% block javascripts %}

<script>
    document.addEventListener('DOMContentLoaded', function() {
    // Load hall data and render stalls
    const hallDisplay = document.getElementById('hall-display');
    const hallId = hallDisplay.dataset.hallId;
    const hallLength = parseInt(hallDisplay.dataset.length);
    const hallBreadth = parseInt(hallDisplay.dataset.breadth);
    const stallInfo = document.getElementById('stall-info');
    const selectedStallsList = document.getElementById('selected-stalls-list');
    const selectedStallsCount = document.getElementById('selected-stalls-count');
    const totalPriceElement = document.getElementById('total-price');
    const discountInfoElement = document.getElementById('discount-info');
    const blockStallsBtn = document.getElementById('block-stalls-btn');
    const unblockStallsBtn = document.getElementById('unblock-stalls-btn');
    const bookStallsBtn = document.getElementById('book-stalls-btn');
    const loadingElement = document.getElementById('loading');
    const bookingModal = document.getElementById('booking-modal');
    const closeBookingModal = document.getElementById('close-booking-modal');
    const bookingForm = document.getElementById('booking-form');
    const confirmationModal = document.getElementById('confirmation-modal');
    const closeConfirmationModal = document.getElementById('close-confirmation-modal');
    const closeConfirmationBtn = document.getElementById('close-confirmation-btn');

    let selectedStalls = [];
    let stallData = {};
    let comboData = {};
    let stallToComboMap = {}; // Maps stall IDs to their combos
    let lastBookingReference = null; // To store the last booking reference for multiple stall selection

    // Determine the scale to fit the display
    const maxWidth = hallDisplay.clientWidth;
    const maxHeight = hallDisplay.clientHeight;

    const scaleX = maxWidth / hallLength;
    const scaleY = maxHeight / hallBreadth;
    const scale = Math.min(scaleX, scaleY);

    // Set the actual dimensions
    const actualWidth = hallLength * scale;
    const actualHeight = hallBreadth * scale;

    // Draw hall grid (for reference)
    for (let x = 0; x < hallLength; x++) {
        for (let y = 0; y < hallBreadth; y++) {
            const gridBox = document.createElement('div');
            gridBox.style.position = 'absolute';
            gridBox.style.left = `${x * scale}px`;
            gridBox.style.top = `${y * scale}px`;
            gridBox.style.width = `${scale}px`;
            gridBox.style.height = `${scale}px`;
            gridBox.style.border = '1px solid #eee';
            hallDisplay.appendChild(gridBox);
        }
    }

    // Fetch and render stalls and combos
    fetch(`/halls/${hallId}/data/`)
        .then(response => response.json())
        .then(data => {
            // Hide loading indicators
            loadingElement.style.display = 'none';
            
            // Store combo data
            data.combos.forEach(combo => {
                comboData[combo.id] = combo;
                
                // Map stalls to their combos
                combo.stall_ids.forEach(stallId => {
                    if (!stallToComboMap[stallId]) {
                        stallToComboMap[stallId] = [];
                    }
                    stallToComboMap[stallId].push(combo.id);
                });
            });
            
            // Process each stall
            data.stalls.forEach(stall => {
                // Store all stall data for reference
                stallData[stall.id] = stall;
                
                const stallBoxes = stall.selected_boxes;

                // Group boxes by stall number and find the boundaries
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

                stallBoxes.forEach(box => {
                    minX = Math.min(minX, box.x);
                    minY = Math.min(minY, box.y);
                    maxX = Math.max(maxX, box.x);
                    maxY = Math.max(maxY, box.y);
                });

                // Create a single stall element
                const stallElement = document.createElement('div');
                stallElement.className = `stall ${stall.status}`;
                stallElement.setAttribute('data-stall-id', stall.id);
                stallElement.setAttribute('data-stall-number', stall.stall_number);
                stallElement.setAttribute('data-stall-status', stall.status);
                stallElement.setAttribute('data-stall-price', stall.price);
                
                // If the stall is part of a combo, add the combo class
                if (stallToComboMap[stall.id]) {
                    stallElement.classList.add('combo');
                    // Store combo IDs as data attribute
                    stallElement.setAttribute('data-combo-ids', stallToComboMap[stall.id].join(','));
                }
                
                stallElement.style.position = 'absolute';
                stallElement.style.left = `${minX * scale}px`;
                stallElement.style.top = `${minY * scale}px`;
                stallElement.style.width = `${(maxX - minX + 1) * scale}px`;
                stallElement.style.height = `${(maxY - minY + 1) * scale}px`;
                stallElement.style.zIndex = '5'; // Ensure stalls appear above grid lines

                // Add the stall number
                const stallLabel = document.createElement('div');
                stallLabel.textContent = stall.stall_number;
                stallLabel.style.position = 'absolute';
                stallLabel.style.top = '50%';
                stallLabel.style.left = '50%';
                stallLabel.style.transform = 'translate(-50%, -50%)';
                stallLabel.style.color = 'white';
                stallLabel.style.fontWeight = 'bold';
                stallLabel.style.fontSize = `${Math.max(14, scale / 3)}px`;
                stallLabel.style.textAlign = 'center';

                // Add click event ONLY for available and blocked stalls (not booked) - FIX #1
                if (stall.status !== 'booked') {
                    stallElement.addEventListener('click', function() {
                        const stallId = this.getAttribute('data-stall-id');
                        const isSelected = this.classList.contains('selected');
                        const comboIds = this.getAttribute('data-combo-ids');
                        const status = this.getAttribute('data-stall-status');
                        
                        if (comboIds) {
                            // This stall is part of a combo
                            const comboIdArray = comboIds.split(',');
                            
                            if (!isSelected) {
                                // When selecting a stall that's part of a combo, auto-select all combo stalls
                                let selectedCombo = null;
                                
                                // Find the first valid combo
                                for (const comboId of comboIdArray) {
                                    const combo = comboData[comboId];
                                    if (!combo) continue;
                                    selectedCombo = combo;
                                    break;
                                }
                                
                                if (selectedCombo) {
                                    // Select all stalls in this combo automatically (if they're not booked) - FIX #1
                                    selectedCombo.stall_ids.forEach(id => {
                                        const comboStallElement = document.querySelector(
                                            `.stall[data-stall-id="${id}"]`
                                        );
                                        const comboStallStatus = comboStallElement?.getAttribute('data-stall-status');
                                        if (comboStallElement && comboStallStatus !== 'booked' && !selectedStalls.includes(id.toString())) {
                                            comboStallElement.classList.add('selected');
                                            selectedStalls.push(id.toString());
                                        }
                                    });
                                } else {
                                    // No valid combo, just select this stall
                                    this.classList.add('selected');
                                    selectedStalls.push(stallId);
                                }
                            } else {
                                // When deselecting, check if part of a fully selected combo
                                let comboToDeselect = null;
                                
                                for (const comboId of comboIdArray) {
                                    const combo = comboData[comboId];
                                    if (!combo) continue;
                                    
                                    // Check if all stalls in this combo are selected
                                    const allSelected = combo.stall_ids.every(id => 
                                        selectedStalls.includes(id.toString())
                                    );
                                    
                                    if (allSelected) {
                                        comboToDeselect = combo;
                                        break;
                                    }
                                }
                                
                                if (comboToDeselect) {
                                    // Deselect all stalls in this combo
                                    comboToDeselect.stall_ids.forEach(id => {
                                        const comboStallElement = document.querySelector(
                                            `.stall[data-stall-id="${id}"]`
                                        );
                                        if (comboStallElement) {
                                            comboStallElement.classList.remove('selected');
                                        }
                                        selectedStalls = selectedStalls.filter(sid => sid !== id.toString());
                                    });
                                } else {
                                    // Just deselect this stall
                                    this.classList.remove('selected');
                                    selectedStalls = selectedStalls.filter(id => id !== stallId);
                                }
                            }
                        } else {
                            // Regular stall (not part of a combo), toggle selection
                            if (isSelected) {
                                this.classList.remove('selected');
                                selectedStalls = selectedStalls.filter(id => id !== stallId);
                            } else {
                                this.classList.add('selected');
                                selectedStalls.push(stallId);
                            }
                        }
                        
                        // Update selected stalls UI
                        updateSelectedStallsUI();
                    });
                } else {
                    // For booked stalls, add a non-selectable visual indicator
                    stallElement.style.cursor = 'not-allowed';
                }

                stallElement.appendChild(stallLabel);
                hallDisplay.appendChild(stallElement);
            });
        })
        .catch(error => {
            console.error('Error loading hall data:', error);
            loadingElement.textContent = 'Error loading stalls. Please try again later.';
        });

    // Update the updateSelectedStallsUI function to store the calculated price
    function updateSelectedStallsUI() {
        // Clear the list
        selectedStallsList.innerHTML = '';
        
        // Update counter
        selectedStallsCount.textContent = `${selectedStalls.length} stalls selected`;
        
        if (selectedStalls.length === 0) {
            stallInfo.style.display = 'none';
            blockStallsBtn.disabled = true;
            unblockStallsBtn.disabled = true;
            bookStallsBtn.disabled = true;
            return;
        }
        
        // Show the stall info section
        stallInfo.style.display = 'block';
        
        // Calculate total price and prepare discount info
        let totalPrice = 0;
        let regularStallCount = 0;
        let discountAmount = 0;
        
        // Group selected stalls by combo
        const comboGroups = {};
        const singleStalls = [];
        
        // Track stall types for button visibility
        const hasBookedStalls = selectedStalls.some(id => stallData[id] && stallData[id].status === 'booked');
        const hasBlockedStalls = selectedStalls.some(id => stallData[id] && stallData[id].status === 'blocked');
        const hasAvailableStalls = selectedStalls.some(id => stallData[id] && stallData[id].status === 'available');
        
        // FIX #2 - Set button visibility based on stall status selection
        if (hasBookedStalls && !hasBlockedStalls && !hasAvailableStalls) {
            // Only booked stalls selected - hide all buttons
            blockStallsBtn.style.display = 'none';
            unblockStallsBtn.style.display = 'none';
            bookStallsBtn.style.display = 'none';
        } else if (hasAvailableStalls && !hasBlockedStalls && !hasBookedStalls) {
            // Only available stalls selected - show block and book buttons
            blockStallsBtn.style.display = 'inline-block';
            unblockStallsBtn.style.display = 'none';
            bookStallsBtn.style.display = 'inline-block';
            
            // Enable buttons
            blockStallsBtn.disabled = false;
            bookStallsBtn.disabled = false;
        } else if (hasBlockedStalls && !hasAvailableStalls && !hasBookedStalls) {
            // Only blocked stalls selected - show unblock and book buttons
            blockStallsBtn.style.display = 'none';
            unblockStallsBtn.style.display = 'inline-block';
            bookStallsBtn.style.display = 'inline-block'; // FIX #2 - Show book button for blocked stalls
            
            // Enable unblock button
            unblockStallsBtn.disabled = false;
            // Enable book button - FIX #2 - Allow direct booking from blocked state
            bookStallsBtn.disabled = false;
        } else {
            // Mixed selection - show all buttons but manage their enabled state
            blockStallsBtn.style.display = 'inline-block';
            unblockStallsBtn.style.display = 'inline-block';
            bookStallsBtn.style.display = 'inline-block';
            
            // Enable/disable buttons based on selection
            blockStallsBtn.disabled = !hasAvailableStalls;
            unblockStallsBtn.disabled = !hasBlockedStalls;
            // Allow booking if either available or blocked stalls are selected - FIX #2
            bookStallsBtn.disabled = !(hasAvailableStalls || hasBlockedStalls);
        }
        
        // Process selected stalls to group them by combo and calculate prices
        selectedStalls.forEach(stallId => {
            const stall = stallData[stallId];
            if (!stall) return;
            
            // Check if this stall is part of a combo where all other stalls are also selected
            let partOfSelectedCombo = false;
            
            if (stallToComboMap[stallId]) {
                for (const comboId of stallToComboMap[stallId]) {
                    const combo = comboData[comboId];
                    if (!combo) continue;
                    
                    // Check if all stalls in this combo are selected
                    const allSelected = combo.stall_ids.every(id => 
                        selectedStalls.includes(id.toString())
                    );
                    
                    if (allSelected) {
                        // Add to combo group
                        if (!comboGroups[comboId]) {
                            comboGroups[comboId] = {
                                combo: combo,
                                stalls: []
                            };
                        }
                        comboGroups[comboId].stalls.push(stall);
                        partOfSelectedCombo = true;
                        break;
                    }
                }
            }
            
            if (!partOfSelectedCombo) {
                // Add to single stalls
                singleStalls.push(stall);
                totalPrice += stall.price;
                regularStallCount++; // Count for discount
            }
        });
        
        // Add combo groups to the list
        for (const comboId in comboGroups) {
            const { combo, stalls } = comboGroups[comboId];
            
            // Use combo price if available, otherwise sum individual stall prices
            const comboPrice = combo.price;
            totalPrice += comboPrice;
            
            const comboItem = document.createElement('div');
            comboItem.className = 'selected-stall-item combo-stall-item';
            comboItem.style.width = "100%";
            comboItem.innerHTML = `
                <div style="flex: 1;">
                    <strong>${combo.name}</strong> - Combo Pack (₹${comboPrice.toFixed(2)})
                    <div style="font-size: 0.85em; margin-top: 3px;">
                        Includes: ${stalls.map(s => s.stall_number).join(', ')}
                    </div>
                </div>
                <span class="remove-stall" data-combo-id="${comboId}">×</span>
            `;
            
            selectedStallsList.appendChild(comboItem);
            
            // Add remove button click event
            const removeBtn = comboItem.querySelector('.remove-stall');
            removeBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                const comboIdToRemove = this.getAttribute('data-combo-id');
                const combo = comboData[comboIdToRemove];
                
                if (combo) {
                    // Remove all stalls in this combo
                    combo.stall_ids.forEach(stallId => {
                        // Remove selection highlight
                        const stallElement = document.querySelector(`.stall[data-stall-id="${stallId}"]`);
                        if (stallElement) {
                            stallElement.classList.remove('selected');
                        }
                        
                        // Remove from selected array
                        selectedStalls = selectedStalls.filter(id => id !== stallId.toString());
                    });
                }
                
                // Update UI
                updateSelectedStallsUI();
            });
        }
        
        // Add single stalls to the list
        singleStalls.forEach(stall => {
            const stallItem = document.createElement('div');
            stallItem.className = 'selected-stall-item';
            
            // Add status class for visual indication
            if (stall.status === 'booked') {
                stallItem.classList.add('booked-stall-item');
                stallItem.style.borderLeft = '3px solid #F44336';
            } else if (stall.status === 'blocked') {
                stallItem.classList.add('blocked-stall-item');
                stallItem.style.borderLeft = '3px solid #9E9E9E';
            }
            
            stallItem.innerHTML = `
                Stall #${stall.stall_number} (₹${stall.price.toFixed(2)}) 
                <span style="font-size: 0.85em; margin-left: 5px;">
                    [${stall.status.charAt(0).toUpperCase() + stall.status.slice(1)}]
                </span>
                <span class="remove-stall" data-stall-id="${stall.id}">×</span>
            `;
            
            selectedStallsList.appendChild(stallItem);
            
            // Add remove button click event
            const removeBtn = stallItem.querySelector('.remove-stall');
            removeBtn.addEventListener('click', function(e) {
                e.stopPropagation();
                const stallIdToRemove = this.getAttribute('data-stall-id');
                
                // Remove selection highlight
                const stallElement = document.querySelector(`.stall[data-stall-id="${stallIdToRemove}"]`);
                if (stallElement) {
                    stallElement.classList.remove('selected');
                }
                
                // Remove from selected array
                selectedStalls = selectedStalls.filter(id => id !== stallIdToRemove);
                
                // Update UI
                updateSelectedStallsUI();
            });
        });
        
        // FIX #3 - Calculate discount based on regular stalls count
        let originalPrice = totalPrice;
        
        if (regularStallCount === 2) {
            // Flat ₹5,000 discount for 2 stalls
            discountAmount = 5000;
            totalPrice -= discountAmount;
        } else if (regularStallCount > 2) {
            // ₹5,000 discount per stall for 3+ stalls
            discountAmount = 5000 * regularStallCount;
            totalPrice -= discountAmount;
        }
        
        // Update total price
        totalPriceElement.textContent = `Total: ₹${totalPrice.toFixed(2)}`;
        
        // Store the calculated price globally - FIX #5 - Store final price for confirmation
        calculatedTotalPrice = totalPrice;
        
        // Update discount info - FIX #3
        if (discountAmount > 0) {
            discountInfoElement.style.display = 'block';
            discountInfoElement.textContent = `Discount applied: ₹${discountAmount.toFixed(2)} (Original price: ₹${originalPrice.toFixed(2)})`;
        } else {
            discountInfoElement.style.display = 'none';
        }
    }

    // Update the updateStallStatus function to use the calculated price
    function updateStallStatus(stallIds, newStatus, customerData = null) {
    const loadingElement = document.getElementById('loading');
    loadingElement.style.display = 'flex';
    loadingElement.textContent = `Updating ${stallIds.length} stall(s)...`;

    // If we're booking stalls and have a previous booking reference, use it
    if (newStatus === 'booked' && customerData && lastBookingReference) {
        customerData.booking_reference = lastBookingReference;
    }

    // For booked status, create a single booking by handling the first stall differently
    if (newStatus === 'booked' && customerData) {
        // Create a booking with the first stall
        const firstStallId = stallIds[0];
        const data = new FormData();
        data.append('status', newStatus);
        
        // Add customer data
        for (const [key, value] of Object.entries(customerData)) {
            data.append(key, value);
        }
        
        // Add the total_amount from our calculation
        if (calculatedTotalPrice) {
            data.append('total_amount', calculatedTotalPrice);
        }
        
        // Process first stall to create booking
        fetch(`/admin_stall/${firstStallId}/update-status/`, {
            method: 'POST',
            body: data,
            headers: {
                'X-CSRFToken': getCookie('csrftoken')
            }
        })
        .then(response => response.json())
        .then(result => {
            if (result.success && result.booking_reference) {
                // Store the booking reference for the remaining stalls
                lastBookingReference = result.booking_reference;
                
                // Now process remaining stalls with the same booking reference
                const remainingStallIds = stallIds.slice(1);
                
                if (remainingStallIds.length > 0) {
                    const promises = remainingStallIds.map(stallId => {
                        const remainingData = new FormData();
                        remainingData.append('status', newStatus);
                        
                        // Add customer data including the booking reference
                        for (const [key, value] of Object.entries(customerData)) {
                            remainingData.append(key, value);
                        }
                        remainingData.append('booking_reference', lastBookingReference);
                        remainingData.append('total_amount', calculatedTotalPrice);
                        
                        return fetch(`/admin_stall/${stallId}/update-status/`, {
                            method: 'POST',
                            body: remainingData,
                            headers: {
                                'X-CSRFToken': getCookie('csrftoken')
                            }
                        }).then(response => response.json());
                    });
                    
                    return Promise.all(promises).then(remainingResults => {
                        // Process all results
                        const allResults = [result, ...remainingResults];
                        processResults(allResults, stallIds, newStatus, customerData);
                    });
                } else {
                    // Only one stall was selected
                    processResults([result], stallIds, newStatus, customerData);
                }
            } else {
                // Handle failure
                loadingElement.style.display = 'none';
                alert('Failed to create booking. Please try again.');
            }
        })
        .catch(error => {
            console.error('Error in booking:', error);
            loadingElement.style.display = 'none';
            alert('There was an error updating the stall status. Please try again.');
        });
    } else {
        // For other statuses (blocked, available), process normally
        const promises = stallIds.map(stallId => {
            const data = new FormData();
            data.append('status', newStatus);

            if (customerData) {
                for (const [key, value] of Object.entries(customerData)) {
                    data.append(key, value);
                }
            }

            return fetch(`/admin_stall/${stallId}/update-status/`, {
                method: 'POST',
                body: data,
                headers: {
                    'X-CSRFToken': getCookie('csrftoken')
                }
            }).then(response => response.json());
        });

        Promise.all(promises)
            .then(results => {
                processResults(results, stallIds, newStatus, customerData);
            })
            .catch(error => {
                console.error('Error updating stalls:', error);
                loadingElement.style.display = 'none';
                alert('There was an error updating the stall status. Please try again.');
            });
    }
}

    // Helper function to process results after stall updates
    function processResults(results, stallIds, newStatus, customerData) {
        const loadingElement = document.getElementById('loading');
        loadingElement.style.display = 'none';

        const failures = results.filter(r => !r.success);
        if (failures.length > 0) {
            alert(`Warning: ${failures.length} stall updates failed.`);
        }

        // For booking operations, handle the booking reference
        if (newStatus === 'booked') {
            const bookingResult = results.find(r => r.booking_reference);
            if (bookingResult && bookingResult.booking_reference) {
                lastBookingReference = bookingResult.booking_reference;
                
                // Show booking confirmation with calculated total price
                if (customerData) {
                    showBookingConfirmation(
                        bookingResult.booking_reference,
                        customerData.customer_name,
                        calculatedTotalPrice,  // Use calculated price with discounts applied
                        stallIds.map(id => stallData[id]?.stall_number).filter(Boolean).join(', ')
                    );
                }
            }
        }

        // Update stall UI elements
        stallIds.forEach(stallId => {
            const stallElement = document.querySelector(`.stall[data-stall-id="${stallId}"]`);
            if (stallElement) {
                // Update classes and data attributes
                stallElement.classList.remove('available', 'booked', 'blocked');
                stallElement.classList.add(newStatus);
                stallElement.setAttribute('data-stall-status', newStatus);
                
                // Update data store
                if (stallData[stallId]) {
                    stallData[stallId].status = newStatus;
                }
                
                // Remove click event for booked stalls
                if (newStatus === 'booked') {
                    const newElement = stallElement.cloneNode(true);
                    stallElement.parentNode.replaceChild(newElement, stallElement);
                    newElement.style.cursor = 'not-allowed';
                }
            }
        });

        // Clear selected stalls
        selectedStalls = [];
        document.querySelectorAll('.stall.selected').forEach(el => {
            el.classList.remove('selected');
        });

        // Update UI
        updateSelectedStallsUI();
    }

    // Modified showBookingConfirmation function to format the amount correctly
    function showBookingConfirmation(reference, customer, amount, stallNumbers) {
        document.getElementById('confirmation-reference').textContent = reference;
        document.getElementById('confirmation-customer').textContent = customer;
        document.getElementById('confirmation-amount').textContent = parseFloat(amount).toFixed(2);  // Ensure proper formatting
        document.getElementById('confirmation-stalls').textContent = stallNumbers;
        confirmationModal.style.display = 'flex';
    }

    // Helper function to get CSRF token
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }
    
    // Block stalls button click event
    blockStallsBtn.addEventListener('click', function() {
        // Get all available stalls from selection
        const availableStalls = selectedStalls.filter(id => 
            stallData[id] && stallData[id].status === 'available'
        );
        
        if (availableStalls.length === 0) {
            alert('No available stalls selected to block.');
            return;
        }
        
        if (confirm(`Block ${availableStalls.length} stall(s)?`)) {
            updateStallStatus(availableStalls, 'blocked');
        }
    });
    
    // Unblock stalls button click event
    unblockStallsBtn.addEventListener('click', function() {
        // Get all blocked stalls from selection
        const blockedStalls = selectedStalls.filter(id => 
            stallData[id] && stallData[id].status === 'blocked'
        );
        
        if (blockedStalls.length === 0) {
            alert('No blocked stalls selected to unblock.');
            return;
        }
        
        if (confirm(`Unblock ${blockedStalls.length} stall(s)?`)) {
            updateStallStatus(blockedStalls, 'available');
        }
    });
    
    // Book stalls button click event - FIX #2 - Allow direct booking for blocked stalls
    bookStallsBtn.addEventListener('click', function() {
        // Get all available AND blocked stalls from selection
        const bookableStalls = selectedStalls.filter(id => 
            stallData[id] && (stallData[id].status === 'available' || stallData[id].status === 'blocked')
        );
        
        if (bookableStalls.length === 0) {
            alert('No available or blocked stalls selected to book.');
            return;
        }
        
        // Show booking modal
        bookingModal.style.display = 'flex';
        
        // Store available stalls for form submission
        bookingForm.setAttribute('data-stall-ids', bookableStalls.join(','));
    });
    
    // Close booking modal
    closeBookingModal.addEventListener('click', function() {
        bookingModal.style.display = 'none';
    });
    
    // Close confirmation modal - FIX #4
    closeConfirmationModal.addEventListener('click', function() {
        confirmationModal.style.display = 'none';
    });
    
    closeConfirmationBtn.addEventListener('click', function() {
        confirmationModal.style.display = 'none';
    });
    
    // Close modal when clicking outside
    window.addEventListener('click', function(event) {
        if (event.target === bookingModal) {
            bookingModal.style.display = 'none';
        }
        if (event.target === confirmationModal) {
            confirmationModal.style.display = 'none';
        }
    });
    
    // Booking form submission
    bookingForm.addEventListener('submit', function(event) {
        event.preventDefault();
        
        const stallIds = this.getAttribute('data-stall-ids').split(',');
        
        if (stallIds.length === 0) {
            alert('No stalls selected for booking.');
            return;
        }
        
        // Collect customer data
        const customerData = {
            customer_name: document.getElementById('customer_name').value,
            customer_email: document.getElementById('customer_email').value,
            customer_phone: document.getElementById('customer_phone').value,
            company_name: document.getElementById('company_name').value,
            notes: document.getElementById('notes').value,
            is_admin_booking: true,
            total_amount: calculatedTotalPrice // Include the total amount in the customer data
        };
        
        // Validate required fields
        if (!customerData.customer_name || !customerData.customer_email || !customerData.customer_phone) {
            alert('Please fill in all required fields.');
            return;
        }
        
        // Update status and create booking for all stalls at once
        updateStallStatus(stallIds, 'booked', customerData);
        
        // Clear form and hide modal
        this.reset();
        bookingModal.style.display = 'none';
    });
    
    // Keyboard event to close modal with Escape key
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
            if (bookingModal.style.display === 'flex') {
                bookingModal.style.display = 'none';
            }
            if (confirmationModal.style.display === 'flex') {
                confirmationModal.style.display = 'none';
            }
        }
    });
    
    // Shift key tracking for multi-select
    let isShiftPressed = false;
    let lastSelectedStallId = null;
    
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Shift') {
            isShiftPressed = true;
        }
    });
    
    document.addEventListener('keyup', function(event) {
        if (event.key === 'Shift') {
            isShiftPressed = false;
        }
    });
    
    // Multi-select functionality for stalls
    document.addEventListener('click', function(event) {
        const stallElement = event.target.closest('.stall');
        
        if (stallElement && isShiftPressed && lastSelectedStallId) {
            event.preventDefault();
            
            const currentStallId = stallElement.getAttribute('data-stall-id');
            
            // Get all stall elements as an array
            const allStalls = Array.from(document.querySelectorAll('.stall'));
            
            // Find indices of last selected and current stalls
            const lastIndex = allStalls.findIndex(s => s.getAttribute('data-stall-id') === lastSelectedStallId);
                const currentIndex = allStalls.findIndex(s => s.getAttribute('data-stall-id') === currentStallId);
                
                if (lastIndex !== -1 && currentIndex !== -1) {
                    // Determine range to select
                    const start = Math.min(lastIndex, currentIndex);
                    const end = Math.max(lastIndex, currentIndex);
                    
                    // Select all stalls in range
                    for (let i = start; i <= end; i++) {
                        const stallToSelect = allStalls[i];
                        const stallId = stallToSelect.getAttribute('data-stall-id');
                        
                        if (!stallToSelect.classList.contains('selected')) {
                            stallToSelect.classList.add('selected');
                            
                            if (!selectedStalls.includes(stallId)) {
                                selectedStalls.push(stallId);
                            }
                        }
                    }
                    
                    // Update UI
                    updateSelectedStallsUI();
                }
            }
            
            // Update last selected stall
            if (stallElement) {
                lastSelectedStallId = stallElement.getAttribute('data-stall-id');
            }
        });
        
        // Add keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            // Ctrl+A to select all available stalls
            if ((event.ctrlKey || event.metaKey) && event.key === 'a') {
                event.preventDefault();
                
                // Select all available stalls
                document.querySelectorAll('.stall.available').forEach(stallElement => {
                    stallElement.classList.add('selected');
                    const stallId = stallElement.getAttribute('data-stall-id');
                    if (!selectedStalls.includes(stallId)) {
                        selectedStalls.push(stallId);
                    }
                });
                
                // Update UI
                updateSelectedStallsUI();
            }
            
            // Escape to clear selection
            if (event.key === 'Escape' && bookingModal.style.display !== 'flex') {
                // Clear all selections
                document.querySelectorAll('.stall.selected').forEach(stallElement => {
                    stallElement.classList.remove('selected');
                });
                selectedStalls = [];
                updateSelectedStallsUI();
            }
            
            // B key to block selected available stalls
            if (event.key === 'b' && !event.ctrlKey && !event.metaKey && !event.altKey) {
                // Only if not typing in a form field
                if (!['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName)) {
                    const availableStalls = selectedStalls.filter(id => 
                        stallData[id] && stallData[id].status === 'available'
                    );
                    
                    if (availableStalls.length > 0) {
                        blockStallsBtn.click();
                    }
                }
            }
            
            // U key to unblock selected blocked stalls
            if (event.key === 'u' && !event.ctrlKey && !event.metaKey && !event.altKey) {
                // Only if not typing in a form field
                if (!['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName)) {
                    const blockedStalls = selectedStalls.filter(id => 
                        stallData[id] && stallData[id].status === 'blocked'
                    );
                    
                    if (blockedStalls.length > 0) {
                        unblockStallsBtn.click();
                    }
                }
            }
        });
        
        // Initial UI update
        updateSelectedStallsUI();
    });


</script>

{% endblock javascripts %}
